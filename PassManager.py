#SYST230Project
from cryptography.fernet import Fernet
import os
import os.path
from pathlib import Path
import random
import zipfile
import pyzipper
import pandas as pd
import getpass
import string

#Fernet: https://www.thepythoncode.com/article/encrypt-decrypt-files-symmetric-python
"""
In short: 
a) Fernet generates a key. that key can be used to encrypt and decrypt data. It will look similar to this:
   "9AFosuDE9Ytk4dPXUDhyPdMhus0_d5knBp585mLlGs4="
b) Next, a nested list is made saved to a file called "Vault.csv". Here is where passwords will be stored. in a format like 
	[["Netflix","P@55w0rd!"], ["Amazon","Password123!"]]
c) The key will be used to encrypt and decrypt this data when read from Vault.csv
d) When not in use, the key is zipped with a password (the master password). This will only be unzipped to decrypt or encrypt "Vault.csv"
"""
#TODO: 
"""
1) UI 
2) check to make sure passwords generated are unique within the Vault
3) something to prevent brute forcing passwords
4) a fix for getFernetKey so that when a password error is thrown it does not brake the vault when it is encrypted
	-> likely solution is to run a while loop with 3 tries for a password. If all have been taken up, it should run a function
	that has yet to be created called "badPassLock" which overrites or deletes key.key.zip
5) making sure the master password contains at least 8 characters, has upper and lowercase, a number, and a special character
6) Autolock in case of error <- May not be needed
7) Delete a password
8) Make sure names for passwords are unique within the vault
9) Make sure that the user can change the master password
"""

def generatePassword(): #generates a random 12 character password. For later use
	valid_chars = list(string.ascii_letters + string.digits + "!@#$%^&*()")
	newpass = ''.join(random.choice(valid_chars) for _ in range(16))
	return(newpass)

def write_key():#this generates a key for the master password. This should ONLY be used when the program is first used
	key = Fernet.generate_key()
	with open("key.key", "wb") as key_file:
		key_file.write(key)

def zip_and_delete(inputfile, password): #used to zip a file and delete the non password protected one
	secret_password = password
	with pyzipper.AESZipFile(inputfile+'.zip','w',compression=pyzipper.ZIP_LZMA,encryption=pyzipper.WZ_AES) as zf:
		zf.setpassword(secret_password)
		with open(inputfile, 'r') as file:
			data = file.read()
			zf.writestr(inputfile, data)
	with pyzipper.AESZipFile(inputfile+'.zip') as zf:
		zf.setpassword(secret_password)
		my_secrets = zf.read(inputfile)
	os.remove(inputfile)

def zipWithUserPass(pass1, pass2): #this zips the key.key file ( generated by write_key() ) with the inputted password.
	path_to_file = 'key.key'
	path = Path(path_to_file)
	if path.is_file(): #if key.key exists, then
		password = ""
		if pass1 == pass2:
			password = pass1
		else:
			print("Passwords do not match. Try again.")
		zip_and_delete(path_to_file, bytes(password, 'utf-8'))#passes to zip and delete
	else:
		print("A Fernet key was not generated... This is bad...")

def getFernetKey(passinput): #gets firnet key from the zip file without unzipping it
	with pyzipper.AESZipFile('key.key.zip') as f:
		f.pwd = bytes(passinput, 'utf-8')
		file_content = f.read('key.key')
		key_in_mem = (file_content)
		return key_in_mem #returns the key and stores it in memory for use

def createPasswordTable(passinput):
	table = [["Application","Password"]]
	pd.DataFrame(table).to_csv("Vault.csv",index=False)
	encrypt("Vault.csv", getFernetKey(passinput)) #encrypt the Vault

def addToPasswordTable(key, passinput):
	decrypt("Vault.csv", key)#decrypt Vault
	df = pd.read_csv (r"Vault.csv")
	table = df.values.tolist()
	newPass = generatePassword()
	table.append([passinput,newPass])
	pd.DataFrame(table).to_csv("Vault.csv",index=False)
	encrypt("Vault.csv", key)#then encrypt it again

def viewPasswordTable(key):
	vals = ""
	decrypt("Vault.csv", key)#decrypt Vault
	df = pd.read_csv (r"Vault.csv")
	table = df.values.tolist()
	print("\n")
	vals = (df)
	print("\n")
	encrypt("Vault.csv", key)#encrypt vault
	return vals

def encrypt(filename, key): #function used to encrypt Vault.csv
	f = Fernet(key)
	with open(filename, "rb") as file:
		# read all file data
		file_data = file.read()
	# encrypt data
	encrypted_data = f.encrypt(file_data)
	# write the encrypted file
	with open(filename, "wb") as file:
		file.write(encrypted_data)

def decrypt(filename, key): #function used to decrypt Vault.exe
	f = Fernet(key)
	with open(filename, "rb") as file:
		# read the encrypted data
		encrypted_data = file.read()
	# decrypt data
	decrypted_data = f.decrypt(encrypted_data)
	# write the original file
	with open(filename, "wb") as file:
		file.write(decrypted_data)

def initialSetup(pass1,pass2):
	if pass1 == pass2:
		write_key() #creates master AES key for your system
		zipWithUserPass(pass1,pass2) #secure the key with master password
		createPasswordTable(pass2) #sets up vault.csv with default company and password then locks



def run():
	if ("key.key.zip" in os.listdir()) and ("Vault.csv" in os.listdir()):
		key = getFernetKey("Input Password to Log In")
		returning(key)#this should only be run after the first startup has been creates sucessfully
	else:
		print("Lets set up your password manager!\n")
		initialSetup()#this should only be run on first startup
		print("Thanks for setting everything up!\nPlease run the program again to access its features")

#run()


